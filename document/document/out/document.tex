\documentclass[10pt]{article}
% generated by Madoko, version 1.1.6
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={hide},fontspec={True}]{madoko2}


\begin{document}



%mdk-data-line={8}
\mdxtitleblockstart{}
%mdk-data-line={8}
\mdxtitle{\mdline{8}Algorithm Design and Analysis}%mdk
\mdxauthorstart{}
%mdk-data-line={13}
\mdxauthorname{\mdline{13}陈艳辉}%mdk

%mdk-data-line={16}
\mdxauthoraddress{\mdline{16}网络空间安全学院}%mdk

%mdk-data-line={19}
\mdxauthoremail{\mdline{19}201818018670068}%mdk
\mdxauthorend\mdtitleauthorrunning{}{}\mdxtitleblockend%mdk

%mdk-data-line={9}
\section{\mdline{9}1.\hspace*{0.5em}\mdline{9}Greedy Algorithm}\label{sec-greedy-algorithm}%mdk%mdk

%mdk-data-line={10}
\subsection{\mdline{10}1.1.\hspace*{0.5em}\mdline{10}Natural language AND Pseudo-code.}\label{sec-natural-language-and-pseudo-code}%mdk%mdk

%mdk-data-line={11}
\noindent\mdline{11}\hspace*{1em}\mdline{11}for every node whose degree is \mdline{11}$d$\mdline{11}, if it can become a part of some graph,it must connect with \mdline{11}$d$\mdline{11} 
other nodes with \mdline{12}$d$\mdline{12} edges. So we can assume those nodes whose degree is \mdline{12}$d_1$\mdline{12},\mdline{12}$d_2$\mdline{12}\dots{}\mdline{12}.,\mdline{12}$d_n$\mdline{12} can 
exist in the same graph.If we delete a node with \mdline{13}$d$\mdline{13} degree from this graph, there must exist \mdline{13}$d$\mdline{13} nodes 
whose degree can reduce 1.So we can try delete all of nodes of the graph,if there exist a node that 
can\mdline{15}'\mdline{15}t fit the rule above, those nodes can\mdline{15}'\mdline{15}t be exist in the same graph.Otherwise there exists an undirected 
graph \mdline{16}$G = (V, E)$\mdline{16} whose node degrees are precisely the numbers  \mdline{16}$d_1$\mdline{16},\mdline{16}$d_2$\mdline{16}\dots{}\mdline{16}.,\mdline{16}$d_n$\mdline{16}.\mdline{16} \mdline{16}%mdk

%mdk-data-line={19}
\mdhr{}%mdk

%mdk-data-line={20}
\noindent\mdline{20}\textbf{function}\mdline{20} \mdline{20}$IsGraph(Array Of Degree)$\mdline{20}\mdbr
\mdline{21}1:  \mdline{21}\textbf{for}\mdline{21}(every d in D): \mdline{21}\mdbr
\mdline{22}2: \mdline{22}\hspace*{1em}\mdline{22} D-\mdline{22}\textgreater{}\mdline{22}delete() //find \mdline{22}\textbf{d}\mdline{22} nodes  in D whose degree is not 0 and make its degree \mdline{22}-\mdline{22}-\mdline{22}\mdbr
\mdline{23}3: \mdline{23}\hspace*{1em}\mdline{23} \mdline{23}\textbf{while}\mdline{23}( d \mdline{23}\textgreater{}\mdline{23} 0 and i \mdline{23}\textless{}\mdline{23} D-\mdline{23}\textgreater{}\mdline{23}len()) \mdline{23}\mdbr
\mdline{24}4: \mdline{24}\hspace*{1em}\mdline{24}\hspace*{1em}\mdline{24} i=0\mdline{24}\mdbr
\mdline{25}5: \mdline{25}\hspace*{1em}\mdline{25}\hspace*{1em}\mdline{25} \mdline{25}\textbf{if}\mdline{25} ( D\mdline{25}{}[\mdline{25}i\mdline{25}]\mdline{25} \mdline{25}\textgreater{}\mdline{25} 0) \mdline{25}\textbf{then}\mdline{25} :\mdline{25}\mdbr
\mdline{26}6: \mdline{26}\hspace*{1em}\mdline{26}\hspace*{1em}\mdline{26}\hspace*{1em}\mdline{26} D\mdline{26}{}[\mdline{26}i\mdline{26}]\mdline{26}-\mdline{26}-\mdline{26}\mdbr
\mdline{27}7: \mdline{27}\hspace*{1em}\mdline{27}\hspace*{1em}\mdline{27}\hspace*{1em}\mdline{27} d\mdline{27}-\mdline{27}-\mdline{27}\mdbr
\mdline{28}8: \mdline{28}\hspace*{1em}\mdline{28}\hspace*{1em}\mdline{28} \mdline{28}\textbf{end}\mdline{28}\mdbr
\mdline{29}9: \mdline{29}\hspace*{1em}\mdline{29}\hspace*{1em}\mdline{29} i++\mdline{29}\mdbr
\mdline{30}10:\mdline{30}\hspace*{1em}\mdline{30} \mdline{30}\textbf{end}\mdline{30}\mdbr
\mdline{31}11:\mdline{31}\hspace*{1em}\mdline{31}\textbf{if}\mdline{31}( d \mdline{31}\textgreater{}\mdline{31} 0 ) \mdline{31}\textbf{then}\mdline{31} : //if we can\mdline{31}'\mdline{31}t find \mdline{31}\textbf{d}\mdline{31} nodes, it can\mdline{31}'\mdline{31}t be a graph \mdline{31}\mdbr
\mdline{32}12:\mdline{32}\hspace*{1em}\mdline{32}\hspace*{1em}\mdline{32}\textbf{return}\mdline{32}  false\mdline{32}\mdbr
\mdline{33}13:\mdline{33}\hspace*{1em}\mdline{33}\textbf{end}\mdline{33}\mdbr
\mdline{34}14:\mdline{34}\textbf{end}\mdline{34}\mdbr
\mdline{35}15:\mdline{35}\textbf{return}\mdline{35} true // we find for every d in D,so it can become a graph\mdline{35} \mdline{35}%mdk

%mdk-data-line={36}
\mdhr{}%mdk

%mdk-data-line={37}
\subsection{\mdline{37}1.2.\hspace*{0.5em}\mdline{37}Describe the greedy-choice property and optimal substructure.}\label{sec-describe-the-greedy-choice-property-and-optimal-substructure}%mdk%mdk

%mdk-data-line={38}
\noindent\mdline{38}The greedy-choice property is if the remaining nodes can compose a graph when a node is deleted from the graph.\mdline{38} \mdline{38}%mdk

%mdk-data-line={40}
\mdline{40}Optimal substructure:\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}\hspace*{1em}\mdline{40}
\mdline{41}\[  \begin{Bmatrix}
  OPT(d-d[0])\\
  0\\
  \end{Bmatrix}
\]%mdk
\mdline{46}%mdk

%mdk-data-line={49}
\subsection{\mdline{49}1.3.\hspace*{0.5em}\mdline{49}Prove the correctness of your algorithm.}\label{sec-prove-the-correctness-of-your-algorithm}%mdk%mdk

%mdk-data-line={50}
\noindent\mdline{50}\hspace*{1em}\mdline{50}for every node whose degree is \mdline{50}$d$\mdline{50}, if it can become a part of some graph,it must connect with \mdline{50}$d$\mdline{50} 
other nodes with \mdline{51}$d$\mdline{51} edges. So we can assume those nodes whose degree is \mdline{51}$d_1$\mdline{51},\mdline{51}$d_2$\mdline{51}\dots{}\mdline{51}.,\mdline{51}$d_n$\mdline{51} can 
exist in the same graph. If we delete a node with \mdline{52}$d$\mdline{52} degree from this graph, there must exist \mdline{52}$d$\mdline{52} nodes 
whose degree can reduce 1. So we can try delete all of nodes of the graph,if there exist a node that 
can\mdline{54}'\mdline{54}t fit the rule above, those nodes can\mdline{54}'\mdline{54}t be exist in the same graph.Otherwise there exists an undirected 
graph \mdline{55}$G = (V, E)$\mdline{55} whose node degrees are precisely the numbers  \mdline{55}$d_1$\mdline{55},\mdline{55}$d_2$\mdline{55}\dots{}\mdline{55}.,\mdline{55}$d_n$\mdline{55}.\mdline{55} \mdline{55}%mdk

%mdk-data-line={56}
\subsection{\mdline{56}1.4.\hspace*{0.5em}\mdline{56}Analyse the complexity of your algorithm.}\label{sec-analyse-the-complexity-of-your-algorithm}%mdk%mdk

%mdk-data-line={57}
\noindent\mdline{57}Time Complexity is \mdline{57}$O(nd)$\mdline{57} where \mdline{57}$d$\mdline{57} is the average value.%mdk

%mdk-data-line={59}
\section{\mdline{59}2.\hspace*{0.5em}\mdline{59}Greedy Algorithm}\label{sec-greedy-algorithm}%mdk%mdk

%mdk-data-line={60}
\subsection{\mdline{60}2.1.\hspace*{0.5em}\mdline{60}Natural language AND Pseudo-code.}\label{sec-natural-language-and-pseudo-code}%mdk%mdk

%mdk-data-line={61}
\noindent\mdline{61}\hspace*{1em}\mdline{61}Compare the first char of string \mdline{61}$s$\mdline{61} and \mdline{61}$t$\mdline{61},if the two chars are different,delete the first char from
\mdline{62}$s$\mdline{62}. Otherwise delete the first char from \mdline{62}$t$\mdline{62}. Repeat it until \mdline{62}$s$\mdline{62} or \mdline{62}$t$\mdline{62} don\mdline{62}'\mdline{62}t contain any char. In the end,
if the length of \mdline{63}$t$\mdline{63} is 0,\mdline{63}$t$\mdline{63} is a subsequence of \mdline{63}$s$\mdline{63}, otherwise,\mdline{63}$t$\mdline{63} is not a subsequence of \mdline{63}$s$\mdline{63}.  \mdline{63} \mdline{63}%mdk

%mdk-data-line={64}
\mdhr{}%mdk

%mdk-data-line={65}
\noindent\mdline{65}\textbf{function}\mdline{65} \mdline{65}$SubsequenceOf(s,t)$\mdline{65}\mdbr
\mdline{66}1: \mdline{66}\textbf{while}\mdline{66}(s-\mdline{66}\textgreater{}\mdline{66}length\mdline{66} \mdline{66}!= 0 or t-\mdline{66}\textgreater{}\mdline{66}length\mdline{66} \mdline{66}!= 0)\mdline{66}\mdbr
\mdline{67}2: \mdline{67}\hspace*{1em}\mdline{67} \mdline{67}\textbf{if}\mdline{67} ( s-\mdline{67}\textgreater{}\mdline{67}first == t-\mdline{67}\textgreater{}\mdline{67}first ) \mdline{67}\textbf{then}\mdline{67}: \mdline{67}\mdbr
\mdline{68}3: \mdline{68}\hspace*{1em}\mdline{68}\hspace*{1em}\mdline{68} s-\mdline{68}\textgreater{}\mdline{68}delete( s-\mdline{68}\textgreater{}\mdline{68}first )\mdline{68}\mdbr
\mdline{69}4: \mdline{69}\hspace*{1em}\mdline{69}\hspace*{1em}\mdline{69} t-\mdline{69}\textgreater{}\mdline{69}delete( s-\mdline{69}\textgreater{}\mdline{69}first )\mdline{69}\mdbr
\mdline{70}5: \mdline{70}\hspace*{1em}\mdline{70} \mdline{70}\textbf{else}\mdline{70}\mdbr
\mdline{71}6: \mdline{71}\hspace*{1em}\mdline{71}\hspace*{1em}\mdline{71} s-\mdline{71}\textgreater{}\mdline{71}delete( s-\mdline{71}\textgreater{}\mdline{71}first )\mdline{71}\mdbr
\mdline{72}7: \mdline{72}\hspace*{1em}\mdline{72} \mdline{72}\textbf{end}\mdline{72}\mdbr
\mdline{73}8:  \mdline{73}\textbf{end}\mdline{73}\mdbr
\mdline{74}9: \mdline{74}\textbf{if}\mdline{74} ( t-\mdline{74}\textgreater{}\mdline{74}length == 0 ) \mdline{74}\textbf{then}\mdline{74} :\mdline{74}\mdbr
\mdline{75}10:\mdline{75}\hspace*{1em}\mdline{75} \mdline{75}\textbf{return}\mdline{75} true\mdline{75}\mdbr
\mdline{76}11: \mdline{76}\textbf{else}\mdline{76} :\mdline{76}\mdbr
\mdline{77}12:\mdline{77}\hspace*{1em}\mdline{77}\textbf{return}\mdline{77} false\mdline{77} \mdline{77}%mdk

%mdk-data-line={78}
\mdhr{}%mdk

%mdk-data-line={79}
\subsection{\mdline{79}2.2.\hspace*{0.5em}\mdline{79}Describe the greedy-choice property and optimal substructure.}\label{sec-describe-the-greedy-choice-property-and-optimal-substructure}%mdk%mdk

%mdk-data-line={80}
\noindent\mdline{80}The greedy-choice is if the first characters of \mdline{80}$s$\mdline{80} and \mdline{80}$t$\mdline{80} are same.%mdk

%mdk-data-line={82}
\mdline{82}Optimal substructure:\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}\hspace*{1em}\mdline{82}
\mdline{83}\[\begin{Bmatrix}
  OPT(s-s[0],t) \\
  OPT(s-s[0],t-t[0])\\
\end{Bmatrix}
\]%mdk
\mdline{88}%mdk

%mdk-data-line={89}
\subsection{\mdline{89}2.3.\hspace*{0.5em}\mdline{89}Prove the correctness of your algorithm.}\label{sec-prove-the-correctness-of-your-algorithm}%mdk%mdk

%mdk-data-line={90}
\noindent\mdline{90}\hspace*{1em}\mdline{90}Compare the first char of string \mdline{90}$s$\mdline{90} and \mdline{90}$t$\mdline{90},if the two chars are different,delete the first char from
\mdline{91}$s$\mdline{91}. Otherwise delete the first char from \mdline{91}$t$\mdline{91}. Repeat it until \mdline{91}$s$\mdline{91} or \mdline{91}$t$\mdline{91} don\mdline{91}'\mdline{91}t contain any char. In the end,
if the length of \mdline{92}$t$\mdline{92} is 0,\mdline{92}$t$\mdline{92} is a subsequence of \mdline{92}$s$\mdline{92}, otherwise,\mdline{92}$t$\mdline{92} is not a subsequence of \mdline{92}$s$\mdline{92}.%mdk

%mdk-data-line={93}
\subsection{\mdline{93}2.4.\hspace*{0.5em}\mdline{93}Analyse the complexity of your algorithm.}\label{sec-analyse-the-complexity-of-your-algorithm}%mdk%mdk

%mdk-data-line={94}
\noindent\mdline{94}Time Complexity is \mdline{94}$O(Length Of S)$\mdline{94}%mdk

%mdk-data-line={96}
\section{\mdline{96}3.\hspace*{0.5em}\mdline{96}Greedy Algorithm}\label{sec-greedy-algorithm}%mdk%mdk

%mdk-data-line={97}
\subsection{\mdline{97}3.1.\hspace*{0.5em}\mdline{97}Natural language AND Pseudo-code.}\label{sec-natural-language-and-pseudo-code}%mdk%mdk

%mdk-data-line={98}
\noindent\mdline{98}\hspace*{1em}\mdline{98}We need compute \mdline{98}$\lfloor \frac{n}{m} \rfloor$\mdline{98} or \mdline{98}$\lceil \frac{n}{m} \rceil$\mdline{98} as the length of
the first part of the nope we cut. And we need update \mdline{99}$n$\mdline{99} = \mdline{99}$n$\mdline{99} \mdline{99}-  \mdline{99}$\lfloor \frac{n}{m} \rfloor$\mdline{99} or \mdline{99}$\lceil \frac{n}{m} \rceil$\mdline{99}
and \mdline{100}$m$\mdline{100} = \mdline{100}$m$\mdline{100} \mdline{100}- 1, the new rope is the rope without the first part we cut from the rope. So we can repeate 
previous steps until the length of the rope is 0. And We get the maximum product.   \mdline{101} \mdline{101}%mdk

%mdk-data-line={103}
\mdhr{}%mdk

%mdk-data-line={104}
\noindent\mdline{104}\textbf{function}\mdline{104} \mdline{104}$maximum\_product(m,n)$\mdline{104}\mdbr
\mdline{105}1:  \mdline{105}\textbf{while}\mdline{105} ( n is not 0 \mdline{105}\textbf{or}\mdline{105} m == 0 )\mdline{105}\mdbr
\mdline{106}2: \mdline{106}\hspace*{1em}\mdline{106} product = n/m \mdline{106}*\mdline{106} product\mdline{106}\mdbr
\mdline{107}3: \mdline{107}\hspace*{1em}\mdline{107} n = n\mdline{107} \mdline{107}- n/m\mdline{107}\mdbr
\mdline{108}4: \mdline{108}\hspace*{1em}\mdline{108} m = m\mdline{108} \mdline{108}- 1\mdline{108}\mdbr
\mdline{109}5:  \mdline{109}\textbf{end }\mdline{109} \mdline{109}%mdk

%mdk-data-line={110}
\mdhr{}%mdk

%mdk-data-line={111}
\subsection{\mdline{111}3.2.\hspace*{0.5em}\mdline{111}Describe the greedy-choice property and optimal substructure.}\label{sec-describe-the-greedy-choice-property-and-optimal-substructure}%mdk%mdk

%mdk-data-line={112}
\noindent\mdline{112}The greedy-choice is cutting \mdline{112}$\lfloor \frac{n}{m} \rfloor$\mdline{112} or \mdline{112}$\lceil \frac{n}{m} \rceil$\mdline{112} everytime.%mdk

%mdk-data-line={114}
\mdline{114}Optimal substructure: \mdline{114}$OPT(n - \lfloor \frac{n}{m} \rfloor,m-1) * \lfloor \frac{n}{m} \rfloor$\mdline{114}%mdk

%mdk-data-line={115}
\subsection{\mdline{115}3.3.\hspace*{0.5em}\mdline{115}Prove the correctness of your algorithm.}\label{sec-prove-the-correctness-of-your-algorithm}%mdk%mdk

%mdk-data-line={116}
\noindent\mdline{116}The maximum product must be the product of the value closest to the average，so we compute\mdline{116}\mdbr
\mdline{117}$\lfloor \frac{n}{m} \rfloor$\mdline{117} or \mdline{117}$\lceil \frac{n}{m} \rceil$\mdline{117} everytime.%mdk

%mdk-data-line={118}
\subsection{\mdline{118}3.4.\hspace*{0.5em}\mdline{118}Analyse the complexity of your algorithm.}\label{sec-analyse-the-complexity-of-your-algorithm}%mdk%mdk

%mdk-data-line={119}
\noindent\mdline{119}Time Complexity is \mdline{119}$O(m)$\mdline{119}%mdk%mdk


\end{document}
